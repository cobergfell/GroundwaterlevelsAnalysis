# -*- coding: utf-8 -*-
"""
Created on Wed Jun 14 22:11:44 2023

@author: christophe
"""



# from scipy import interpolate
import numpy as np
from scipy.optimize import least_squares, leastsq
from datetime import datetime
from matplotlib.dates import date2num, num2date
from logging import getLogger
from stresstimeseries import Stress
from headstimeseries import Heads
from preprocessedseries import Preprocessed
from parameterslogistic import ParametersLogistic
from modeldefinition import ModelDefinition
from weightingfunctions import Sigmoid
from matplotlib.pyplot import figure, show,savefig,clabel,contour,setp,gcf,getp,gca,close
from unitresp import *
from utilities import *
import numpy as np
import os




class StressConvolution:
    
    """
    A class that provides instances of StressConvolution, consisting of a convolution
    between stresses and their corresonding response functions
    
        ...
    
    Attributes
    ----------
    
    filepath: string
        path to the csv file    
    
    stress_type : string
        A string specifying the type of stress ('prec', 'evap', 'pump', 'riv')   
        
    pnumber: int
        pnumber is the rank of a parameter in the parameter vector      
    
    time : numpy array_like
        An arrays of time numbers generated by matplotlib.dates function date2num
        when prepocessing the input time series using the preprocessedseries.py module
        
    tmin : float
        The minimum time of the preprocessed time series 
        (time number as defined in matplotlib.dates function date2num)

    tmax : float
        The maximum time of the preprocessed time series 
        (time number as defined in matplotlib.dates function date2num)            
           
    p_dict : python object of data type 'dict'
        The dictionary defining the model parameters and associated specifications 
        such as associated indexes, names, logtransformed or not, 
        variable or fixed etc. See the the parameterslogistic.py module for additional details.
        
    arguments_dict : python object of data type 'dict'
        A dictionary specifying additional arguments to pass to the response functions.
        For example: X,Y coordinates of pumping wells          
        
    time_step : float
        The specified time step used for all heads and stresses time series     
          
    settings : python object of data type 'dict' (optional)
        An optional dictionnary of settings - not used in present version        
        
    preprocessed_stress : numpy array_like
        preprocessed_stress is the stress to be convolved after interpolation
        resulting in equidistant time steps, which allow to apply  fast fourrier 
        transform convolution
        
    Nint: int
        The memory of the stress considered expressed 
        in number of time intervals (a time interval equals a time step)        
        
        
    
    Methods
    -------
    
    convolve_stress()
        A method to convolve the stress with the corresponding response function
        or its partial derivatives
        


    """    
    
    
    logger = getLogger(__name__)

        
    def __init__(self, preprocessed_stress = None, filepath = None, stress_type = None,  
                 p_dict = None, time = None, Nint = None, time_step = None, tminstr = None, tmaxstr = None, 
                 tminnum = None, tmaxnum = None, settings = None, arguments_dict = None, pnumber = None ):
        
        self.filepath = filepath
        self.stress_type = stress_type
        self.settings = settings
        self.arguments_dict = arguments_dict
        self.time = time
        self.pnumber = pnumber
        
        clsname = str(self.__class__.__name__)
        modulename = str(__name__)
        
        if tminnum is not None and tminstr is not None:

            message = (f'\nIn class {clsname} line 131 of module {modulename}.py:'
                       f'Minimum time is both given as string and numeric value.'
                       f'String value will be ignored.\n')     
                        
            logger.warning(message)     
            
            
        if tminnum is None and tminstr is None:
            tminstr_default = '01-01-1900'
            dtmin = datetime.strptime(tminstr_default,'%d-%m-%Y')
            tmin = date2num(dtmin)
            
        if tminstr is not None:
            dtmin = datetime.strptime(tminstr,'%d-%m-%Y')
            tmin = date2num(dtmin)
            
        if tminnum is not None:   
             tmin = tminnum
             
             
             
        if tmaxnum is not None and tmaxstr is not None:
             message = (f'\nIn class {clsname} of module {modulename}.py:'
                        f'Maximum time is both given as string and numeric value.'
                        f'String value will be ignored.\n')     

             logger.warning(message)     
            
            
        if tmaxnum is None and tmaxstr is None:
            tmaxstr_default = '31-12-2100'
            dtmax = datetime.strptime(tmaxstr_default,'%d-%m-%Y')
            tmax = date2num(dtmax)

                        
        if tmaxstr is not None:
            dtmax = datetime.strptime(tmaxstr,'%d-%m-%Y')
            tmax = date2num(dtmax)
         
        if tmaxnum is not None:   
             tmax = tmaxnum             
       
        self.tmin = tmin
        self.tmax = tmax      
        
        
        if p_dict == None:
            md = ModelDefinition()
            parametersLogistic = ParametersLogistic(md.model_definition) # by default
            p_dict = parametersLogistic.assemble_p()
        
                
        self.p_dict = p_dict  
         
        self.time_step = time_step
        self.Nint = Nint
        
        if (preprocessed_stress is not None) and (filepath is not None):

            message = (f'\nIn class {clsname} of module {modulename}.py:'
                       f'A stress time series is given both as array and as file.'
                       f'the array will be used and the file ignored.\n')     
                        
            logger.warning(message)     

            
        if (preprocessed_stress is None) and (filepath is None):

            message = (f'\nIn class {clsname} of module {modulename}.py: No stress time series is given.'
                       f'Either a preprocessed time series or a time series as text file '
                       f'should be entered.\n')     
                        
            logger.error(message)     
            


        elif (preprocessed_stress is None) and (filepath is not None):

            if isinstance(filepath,str):
                try:
                    ts = Stress.read_from_csv(filepath, stress_type = stress_type)
                    ts_obs = ts.observed
                    ts_interpolated = Preprocessed.interpolate(ts_obs, time_step = time_step, tmin = tmin, tmax = tmax)
                    self.preprocessed_stress = ts_interpolated
                except FileNotFoundError:
                    message = (f'\nIn class {clsname} of module {modulename}.py:'
                               f'Filepath {filepath} does not exist.\n.')     
                    logger.warning(message)     
             
                        
                        
        else:
            self.preprocessed_stress = preprocessed_stress
        



    
    def convolve_stress(self):   

        """   
        A method to convolve the stress with the corresponding response function
        or its partial derivatives
        
        Parameters
        ----------
        See class attributes
    
        """  
        

        convolved_stresses_list = []
        tmin = self.tmin
        tmax = self.tmax
        stress_type = self.stress_type
        p_dict = self.p_dict
        time = self.time
        Nint = self.Nint
        time_step = self.time_step
        arguments_dict = self.arguments_dict
        
        pnumber = self.pnumber
        
        respfunctclassname = p_dict['componentsnames'][stress_type]       
        p_indexes = p_dict['p_indexes']
        weightingfunctionsnames = p_dict["weightingfunctionsnames"]
        Nregimes = p_dict["number_of_regimes"][stress_type]
          
        clsname = str(self.__class__.__name__)
        modulename = str(__name__)
        
        for i in range(0,Nregimes):
            regime = 'regime_'+str(i+1)

            indices = p_dict["p_indexes"][stress_type][regime]['basicparam']
            p = []
            logtransform = []
                    
            for index in indices:
                p.append(p_dict['p'][index]) 
                logtransform.append(p_dict['logtransform'][index]) 
            p = np.array(p)   
            
            logtransform = np.array(logtransform) 
                       
            
            respfunc = eval( respfunctclassname + "(stress_type = stress_type,Nint = Nint," 
                            "time_step = time_step, arguments_dict = arguments_dict,"
                            "pnumber = pnumber)")
            

            block = respfunc.blockfunction(p ,logtransform)
            preprocessed_stress = self.preprocessed_stress
            preprocessed_stress_time = preprocessed_stress[:,0]
            
            convolved_stress_time =  preprocessed_stress_time[len(block)-1:]
            convolved_stress = np.empty((len(convolved_stress_time),2))
            convolved_stress[:,0] = convolved_stress_time  
            # conv = np.convolve(block,preprocessed_stress[:,1],'valid')
            # convolved_stress[:,1] = conv   

    
            try:
                conv = np.convolve(block,preprocessed_stress[:,1],'valid')        
                convolved_stress[:,1] = conv
      

            except:
                message = (f'\nIn class {clsname} of module {modulename}.py:'
                           f'\nNo convolution could be evaluated for {stress_type} time series.\n')
                logger.warning(message)            
        
            convolved_stresses_list.append(convolved_stress)
            

            output = convolved_stress

        weighted_convolved_stresses_list = [convolved_stresses_list[0]]

        if Nregimes > 1:

            for i in range(1,Nregimes):
                regime = 'regime_'+str(i+1)
                weightingfunctionsname = weightingfunctionsnames[stress_type]
                if weightingfunctionsname == 'sigmoid':

                    weightingfunc = Sigmoid(time = convolved_stress_time, p_dict = p_dict, 
                                            stress_type = stress_type, regime = regime)    
                    weights1,weights2 = weightingfunc.generate_weights()
  
                    superposed_convolved_stresses = np.empty((len(convolved_stress_time),2))
                    superposed_convolved_stresses[:,0] = convolved_stress_time
                    
                    
                    
                    if i < 2:
                        superposed_convolved_stresses[:,1] = (weights1[:,1]*convolved_stresses_list[i-1][:,1] 
                                                            + weights2[:,1]*convolved_stresses_list[i][:,1])   

                    else:    
                        superposed_convolved_stresses[:,1] = (weights1[:,1]*weighted_convolved_stresses_list[i-1][:,1] 
                                        + weights2[:,1]*convolved_stresses_list[i][:,1])
                       
                        
                    weighted_convolved_stresses_list.append(superposed_convolved_stresses)  

                        
            output = weighted_convolved_stresses_list[-1] # last element is the final superposition result

                
            
        
        return output
    
    


if __name__ == "__main__":
    #curdir=os.getcwd()
    abs_path = os.path.dirname(os.path.abspath(__file__))
    abs_path_splitted = abs_path.split('\\')
    path_to_parent_folder_elements = abs_path_splitted[:-1]
    path_to_parent_folder = os.path.join(*path_to_parent_folder_elements)
    splitted = path_to_parent_folder.split(':')#trick  to  repair  path
    path_to_parent_folder = splitted[0]+':\\'+splitted[1]#trick  to  repair  path
    path_to_file_folder = os.path.join(path_to_parent_folder,'resources')
    path_to_file = os.path.join(path_to_file_folder,'260_De_Bilt_PREC_19010101_20200910.csv')
     
    # sc = StressConvolution(filepath = path_to_file, stress_type = 'prec', Nint = int(5 * 365.), time_step = 1.,tminstr = '01-01-1990', tmaxstr = '31-12-2000')
    # convolved_stress = sc.convolve_stress()
    # sc = StressConvolution(filepath = path_to_file, stress_type = 'prec', Nint = int(5 * 365.), time_step = 1.,tminstr = '01-01-1990', tmaxstr = '31-12-2000')
    # convolved_stress_callback_version = sc.convolve_stress_callback_version()
    md = ModelDefinition().model_definition
    memory_dict = ModelDefinition().memory_dict
    time_step = 1.
    time_step_targets = 14.
    
    

    parametersLogistic = ParametersLogistic(md)
    p_dict = parametersLogistic.assemble_p()
    
    
    
    
    
    
    #curdir=os.getcwd()
    model_definition = ModelDefinition().model_definition
    abs_path = os.path.dirname(os.path.abspath(__file__))
    abs_path_splitted = abs_path.split('\\')
    path_to_parent_folder_elements = abs_path_splitted[:-1]
    path_to_parent_folder = os.path.join(*path_to_parent_folder_elements)
    splitted = path_to_parent_folder.split(':')#trick  to  repair  path
    path_to_parent_folder = splitted[0]+':\\'+splitted[1]#trick  to  repair  path
    path_to_file_folder = os.path.join(path_to_parent_folder,'resources')  

    stresses_dict = {}
    
    path_to_file = os.path.join(path_to_file_folder,'260_De_Bilt_PREC_19010101_20200910.csv')
    key = basename(path_to_file)
    stresses_dict['prec'] = {}
    stresses_dict['prec'][key] = Stress.read_from_csv(path_to_file, stress_type = 'prec')    
    

    path_to_file=os.path.join(path_to_file_folder,'260_De_Bilt_EVAP_19010101_20200910.csv')
    key = basename(path_to_file)
    stresses_dict['evap'] = {}
    stresses_dict['evap'][key] = Stress.read_from_csv(path_to_file, stress_type = 'evap')    
    
    tminstr = '01-01-1900 08:00:00'
    tmaxstr = '31-12-2100 08:30:00'

    path_to_file_folder = os.path.join(path_to_parent_folder,'resources')  
    path_to_file = os.path.join(path_to_file_folder,'28AP0093_1.txt')
    heads = Heads.read_from_csv(path_to_file, tminstr = tminstr, tmaxstr = tmaxstr)
        
    time_step = 1.#/(24.*2)
    
    memory_dict = {'prec':365*5,
              'evap':365*5,
              'riv':7,
              'pump':365*5,
              'noise':30}      
    
    
    
    
    preprocessed = Preprocessed(heads = heads,stresses_dict = stresses_dict, time_step = time_step, 
                                model_definition = model_definition, memory_dict = memory_dict,
                                tminstr = tminstr, tmaxstr = tmaxstr).preprocess()
    
    time = preprocessed.time
    heads = preprocessed.heads
    stresses_dict = preprocessed.stresses_dict 
    Nint_dict = preprocessed.Nint_dict
    all_data_for_neural_networks = preprocessed.all_data_for_neural_networks
    all_targets_for_neural_networks = preprocessed.all_targets_for_neural_networks

    

    key = list(stresses_dict['prec'].keys())[0]
    preprocessed_stress = stresses_dict['prec'][key].interpolated
    

    arguments_dict = {}
    arguments_dict['Xriv'] = 0
    arguments_dict['Yriv'] = 0
    arguments_dict['Xpiezo'] = 10 
    arguments_dict['Ypiezo'] = 0      
    arguments_dict['Zpiezo'] = 0
    arguments_dict['Lpiezo'] = 1        
    
    resp = StressConvolution(preprocessed_stress = None, filepath = path_to_file, stress_type = 'prec', 
             p_dict = p_dict, time = None, Nint = 365*2, time_step = 1., tminstr = None, tmaxstr = None, 
             tminnum = None, tmaxnum = None, settings = None, arguments_dict = arguments_dict).convolve_stress()
    
    
    
    # resp = StressConvolution(preprocessed_stress = None, filepath = path_to_file, stress_type = 'prec', 
    #              p_dict = p_dict, time = None, Nint = 365*2, time_step = 1., tminstr = None, tmaxstr = None, 
    #              tminnum = None, tmaxnum = None, settings = None, arguments_dict = None).convolve_stress()
    
    
    
    
    
    fig=figure()
    ax = fig.add_subplot(111)
    ax.set_title('396 inspect resp ')
    ax.plot_date(resp[:,0],resp[:,1],'b')
    leg = ax.legend((["superposedresp"]),loc='upper left',shadow=False)
    ax.set_xlabel('time')
    ax.grid(False)
    show()