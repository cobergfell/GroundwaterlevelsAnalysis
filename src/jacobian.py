# -*- coding: utf-8 -*-
"""
Created on Fri Feb  3 21:02:57 2023

@author: christophe

"""

# from scipy import interpolate
import os
import numpy as np
from datetime import datetime
from matplotlib.dates import date2num, num2date
from matplotlib import pyplot as plt
from logging import getLogger
from stresstimeseries import Stress
from headstimeseries import Heads
from preprocessedseries import Preprocessed
from stressconvolution import StressConvolution
from parameterslogistic import ParametersLogistic
from modeldefinition import ModelDefinition
from modelnoise import ResidualsDecayExponentially
from utilities import datestring2num, basename, generate_ticks
from plotfunctions import simpleplot
from rootzone import Vangenuchten
from modeldefinition import ModelDefinition
from simulation import Simulation

logger = getLogger(__name__)


class Jacobian:
    
    """
        Class that provides instances of time series models analytical jacobians
        (matrix of partial derivatives in respect to model parameters)
    
        ...
    
    Attributes
    ----------

    simulation : Simulation object
        The simulation corresponding to the parameters vector for which the jacobian is to be evaluated     
    
    time : numpy array_like
        Arrays of time numbers generated by matplotlib.dates function date2num
        when prepocessing the input time series using the preprocessedseries.py module
              
    _p_dict : python object of data type 'dict'
        _p_dict is a local copy of the p_dict dictionary defining the model parameters
        and associated specifications such as associated indexes, names, logtransformed or not, 
        variable or fixed etc. See the the parameterslogistic.py module for additional details.
        
    _stresses_dict : python object of data type 'dict'
        _stresses_dict is a local copy of the stresses_dict dictionary containing all the entered
        Stress objects used to explain the observed groundwater levels variations.
        
    _jacobian : Jacobian object
        _jacobian is a local copy of the evaluated jacobian to be accessed, if needed, through getter and setters    
        
    heads : Heads object or list of Heads objects
        Single Heads object or list of Heads objects containing the observed groundwater levels,
        associated metadata and preprocessed versions of the groundwater level time series 

    settings : python object of data type 'dict' (optional)
        An optional dictionnary of settings - not used in present version

    Nint_dict : python object of data type 'dict'
        A dictionary specifying per stress the memory of each stress, expressed 
        in number of time intervals (a time interval equals a time step)
        
    time_step : float
        The specified time step used for all heads and stresses time series     
        
    _components : python object of data type 'dict'
        A dictionary containing the seperate components of the time series model         

    model_definition : Modeldefinition object
        A Modeldefinition object specifying how the time series analysis is implemented 
        (which is the first step in the present time series analysis methodology) 
           
    tmin : float
        The minimum time of the preprocessed time series 
        (time number as defined in matplotlib.dates function date2num)

    tmax : float
        The maximum time of the preprocessed time series 
        (time number as defined in matplotlib.dates function date2num)            

    model_residuals : numpy array_like
        Arrays of simulated model residuals if applicable
        
        
    Methods
    -------   
    evaluate()
        Evaluate the model jacobian


    """    

               
    def __init__(self, simulation):

        self.simulation = simulation
        self._p_dict = simulation.p_dict
        self._stresses_dict = simulation.stresses_dict
        self.time = simulation.time
        self.heads = simulation.heads
        self.settings = simulation.settings
        self.Nint_dict = simulation.Nint_dict
        self.time_step = simulation.time_step
        self._jacobian = None
        self.components = simulation.components
        self.model_definition = simulation.model_definition
        self.tmin = self.time[0]
        self.tmax = self.time[-1]
        self.model_residuals = simulation.model_residuals
  

               
    def __repr__(self):
        """String representation of the simulation."""

        string = 'Convolution of:\n'
        for stress in self._stresses_dict:
            string += f'{repr(self._stresses_dict[stress])}.\n'

        return string
                
            
        
    @property
    def jacobian(self):
        """getter for evaluated jacobian."""
        return self._jacobian

    @jacobian.setter
    def jacobian(self,jacobian):
        """setter for evaluated jacobian."""
        self._jacobian = jacobian  
        

    
    
    def evaluate(self):
        
        """
        Method that returns the jacobian of a time series model given a parameters vector
        
        ----------
        Parameters
        ----------
        The parameters needed are entered by initializing the class object, see Class documentation           
                
        
        Returns
        -------
        simulation: numpy array_like
                array of simulated time series
        
        """
        time = self.time
        heads = self.heads
        X  = heads.X
        Y = heads.Y
        Z = heads.Z
        L = heads.L
        tmin = self.tmin
        tmax = self.tmax
        time_step = self.time_step
        model_residuals = self.model_residuals
        Nint_dict = self.Nint_dict
        settings = self.settings
        model_definition = self.model_definition
        simulation = self.simulation
        
        
        p_dict = {}
        for key in self._p_dict:
            p_dict[key] = self._p_dict[key]
             
        stresses_dict = {}
        for key in self._stresses_dict:
            stresses_dict[key] = self._stresses_dict[key]
            
            
        isvariable = []
        for e in p_dict['isvariable']:
            isvariable.append(e)

        if model_residuals == False:
            if 'noise' in p_dict['p_indexes']:
                indices = p_dict['p_indexes']['noise']['regime_1']['basicparam']
                for index in indices:
                    isvariable[index] = False
                    
        isvariable_det = []
        for e in isvariable:
            isvariable_det.append(e)
            
        if 'noise' in p_dict['p_indexes']:
            indices = p_dict['p_indexes']['noise']['regime_1']['basicparam']
            for index in indices:
                isvariable_det[index] = False

        logtransform = []
        for e in p_dict['logtransform']:
            logtransform.append(e)        
        
        selectparam = np.array(isvariable) # selectparam select variable parameters
        selectparam_det = np.array(isvariable_det) # selectparam_det select variable parameters except those used in noise model
        
        
        selectlog = np.array(logtransform)[selectparam] # selectlog elements are True when a variable parameter is logtransformed
        selectlog_det = np.array(logtransform)[selectparam_det]

        p_init = np.array(p_dict['p_init'])

        nl = len(time)
        nc = len(p_init)
        J = np.zeros((nl,nc))     
            
        p_indexes = p_dict['p_indexes']
        logtransform = p_dict['logtransform']
    
        for stress_type in stresses_dict:
            
            self.components[stress_type] = {}

            Nint = Nint_dict[stress_type]
            if stress_type in ['evap','pump']:
                sign = -1
            else:
                sign = 1


            arguments_dict = {}
            
            toconvolve = True     
            for e in stresses_dict[stress_type]:
                
                if stress_type not in p_dict['componentsnames']:
                    toconvolve = False
                             
                if toconvolve == True:

                    if stress_type == 'pump':
                        
                        arguments_dict['Xwell'] = stresses_dict[stress_type][e].X
                        arguments_dict['Ywell'] = stresses_dict[stress_type][e].Y
                        arguments_dict['Xpiezo'] = X 
                        arguments_dict['Ypiezo'] = Y 
                        arguments_dict['Zpiezo'] = Z
                        arguments_dict['Lpiezo'] = L
                        
                    if model_definition[stress_type]['funct_type'] in ['floodwavemodel2L_typeI']:

                        river_series_name = list(stresses_dict['riv'].keys())[0]#there is only one list element
                        Xriv = stresses_dict['riv'][river_series_name].X
                        Yriv = stresses_dict['riv'][river_series_name].Y                        

                        try:
                            river_series_name = list(stresses_dict['riv'].keys())[0]#there is only one list element
                            Xriv = stresses_dict['riv'][river_series_name].X
                            Yriv = stresses_dict['riv'][river_series_name].Y
    
                            arguments_dict['Xriv'] = Xriv
                            arguments_dict['Yriv'] = Yriv
                            arguments_dict['Xpiezo'] = X 
                            arguments_dict['Ypiezo'] = Y      
                            arguments_dict['Zpiezo'] = Z
                            arguments_dict['Lpiezo'] = L                            
                            
                        except:
                            clsname = str(self.__class__.__name__)
                            modulename = str(__name__)
                            message = (f'\nIn class {clsname} of module {modulename}.py: FloodWaveModel2L'
                                        f'Xriv and Yriv are required imputs when using FloodWaveModel2L as response'
                                        f'for "prec", "evap" or "riv".\n')     
                                        
                            logger.error(message)                          
    
                    if model_definition[stress_type]['use_normalized_time_series'] == True:
                        preprocessed_stress = stresses_dict[stress_type][e].interpolated_normalized   
                    else:
                        preprocessed_stress = stresses_dict[stress_type][e].interpolated
                    
                    if stress_type == 'prec':
                        if self.model_definition['root_zone']['apply_root_zone'] == True:
                            if self.model_definition['root_zone']['funct_type'] == 'vangenuchten':
                                rootzone_instance = Vangenuchten(p_dict = p_dict, stresses_dict = stresses_dict, time_step = 1.0, 
                                  root_zone_model = 'Brooks_and_Corey')
                            else: # make vangenuchten the default root zone model
                                rootzone_instance = Vangenuchten(p_dict = p_dict, stresses_dict = stresses_dict, time_step = 1.0, 
                                  root_zone_model = 'Brooks_and_Corey')
                            
                            preprocessed_stress = rootzone_instance.estimate_percolation()
                        
                    indices = p_dict["p_indexes"][stress_type]['regime_1']['basicparam'] # analytical jacobian only applicable for 1 regime

                    for pnumber in range(0,len(indices)):
                            
                        index = indices[pnumber]

                        sc = StressConvolution(preprocessed_stress = preprocessed_stress, stress_type = stress_type, 
                                               p_dict = p_dict, time = time, Nint = Nint, time_step = time_step, 
                                               tminnum = tmin, tmaxnum = tmax, arguments_dict = arguments_dict, 
                                               pnumber = pnumber)

                        partial_derivative = sc.convolve_stress() 
                        partial_derivative[:,1] *= sign
                        mask = np.isnan(partial_derivative[:,1])
                        partial_derivative[mask,1] = 0
                        J[:,index] += partial_derivative[:,1]

        if p_dict['p_indexes']['db']['regime_1']['basicparam'] != []:
            index = p_indexes['db']['regime_1']['basicparam'][0]
            db = p_dict['p'][index]
   
            if logtransform[index] == True:
                J[:,index] = np.exp(db)
            else:
                J[:,index] = 1
                 
        if model_residuals == True:
            if p_indexes['noise'] is not None:
                index = p_indexes['noise']['regime_1']['basicparam'][0]
                alpha = p_dict['p'][index]
                
                if logtransform[index] == True:
                    alpha = np.exp(alpha)            
                
                noisefunctclassname = p_dict['componentsnames']['noise']
                simulated_residuals = eval( noisefunctclassname + "(p_dict = p_dict, time = time, heads = heads, deterministic_simulation = simulation.simulated).simulate_residuals()")
                partial_derivative = self.time_step * simulated_residuals
                J[:,index] = partial_derivative[:,1]
                if logtransform[index] == True:
                    J[:,index] *= alpha
                    
        selectlines = np.flatnonzero(heads.targets_selector)
        selectcolumns = np.flatnonzero(selectparam)

        J=J.take(selectlines,axis=0) # select lines
        J=J.take(selectcolumns,axis=1) # select colomn

        return J  
    
    
    
    

    
if __name__ == "__main__":

    #curdir=os.getcwd()
    abs_path = os.path.dirname(os.path.abspath(__file__))
    abs_path_splitted = abs_path.split('\\')
    path_to_parent_folder_elements = abs_path_splitted[:-1]
    path_to_parent_folder = os.path.join(*path_to_parent_folder_elements)
    splitted = path_to_parent_folder.split(':')#trick  to  repair  path
    path_to_parent_folder = splitted[0]+':\\'+splitted[1]#trick  to  repair  path
    path_to_file_folder = os.path.join(path_to_parent_folder,'resources')  

    stresses_dict = {}
    
    
    # # test Middle Netherlands
    # path_to_file = os.path.join(path_to_file_folder,'260_De_Bilt_PREC_19010101_20200910.csv')
    # key = basename(path_to_file)
    # stresses_dict['prec'] = {}
    # stresses_dict['prec'][key] = Stress.read_from_csv(csv_file = path_to_file, stress_type = 'prec',cumulative = True)    
    

    # path_to_file=os.path.join(path_to_file_folder,'260_De_Bilt_EVAP_19010101_20200910.csv')
    # key = basename(path_to_file)
    # stresses_dict['evap'] = {}
    # stresses_dict['evap'][key] = Stress.read_from_csv(csv_file = path_to_file, stress_type = 'evap',cumulative = True)    
    
    

    # test river Aa Brabant (Netherlands)
    path_to_file = os.path.join(path_to_file_folder,'375_PREC_19510101_20130603.csv')

    key = basename(path_to_file)
    stresses_dict['prec'] = {}
    stresses_dict['prec'][key] = Stress.read_from_csv(csv_file = path_to_file, stress_type = 'prec',cumulative = True)    

    path_to_file=os.path.join(path_to_file_folder,'375_EVAP_19510101_20130603.csv')

    key = basename(path_to_file)
    stresses_dict['evap'] = {}
    stresses_dict['evap'][key] = Stress.read_from_csv(csv_file = path_to_file, stress_type = 'evap',cumulative = True)    
    
    path_to_file=os.path.join(path_to_file_folder,'raai2_251A_20082012_repared.csv')
    key = basename(path_to_file)
    stresses_dict['riv'] = {}
    stresses_dict['riv'][key] = Stress.read_from_csv(csv_file = path_to_file, stress_type = 'riv',cumulative = False)    

    # test pump
    # stresses_dict['pump'] = {}
    # path_to_files_folder = os.path.join(path_to_parent_folder,'resources','selected_wells_paper1_reformatted')  
    # list_of_files_names = os.listdir(path_to_files_folder)
    # for filename in list_of_files_names:
    #     path_to_file = os.path.join(path_to_files_folder,filename)
    #     key = basename(path_to_file)
    #     stresses_dict['pump'][key] = Stress.read_from_csv(path_to_file, stress_type = 'pump',cumulative = False)    

    tminstr = '01-01-1900 08:00:00'
    tmaxstr = '31-12-2100 08:30:00'
    
    path_to_file_folder = os.path.join(path_to_parent_folder,'resources')  
    path_to_file = os.path.join(path_to_file_folder,'28AP0093_1.txt')
    heads = Heads.read_from_csv(path_to_file, tminstr = tminstr, tmaxstr = tmaxstr)
    
    
    path_to_file_folder = os.path.join(path_to_parent_folder,'resources')  
    path_to_file = os.path.join(path_to_file_folder,'P8.txt')
    heads = Heads.read_from_csv(path_to_file, tminstr = tminstr, tmaxstr = tmaxstr)    
    heads.L = 1 #layer number (index top layer is 0)


    
    # path_to_file_folder = os.path.join(path_to_parent_folder,'resources','selected_filters_paper1')  

    
    # list_of_piezometers_files_names = os.listdir(path_to_file_folder)
    # for filename in list_of_piezometers_files_names: 
    #     path_to_file = os.path.join(path_to_file_folder,filename)
    #     heads = Heads.read_from_csv(path_to_file, tminstr = tminstr, tmaxstr = tmaxstr) 
    #     #heads.plot()



    md = ModelDefinition().model_definition
    memory_dict = ModelDefinition().memory_dict
    parametersLogistic = ParametersLogistic(md)
    
    memory_dict = {'prec':365*5,
          'evap':365*5,
          'riv':7,
          'pump':365*5,
          'noise':30}     
    
    
    memory_dict = {'prec':1000,
          'evap':1000,
          'riv':1000,
          'pump':365,
          'noise':30}         
    
    
    time_step = 1. #1./(24.*2)
    preprocessed = Preprocessed(heads = heads,stresses_dict = stresses_dict, time_step = time_step, 
                                memory_dict = memory_dict,tminstr = tminstr, tmaxstr = tmaxstr,
                                model_definition = md).preprocess()
    time = preprocessed.time
    heads = preprocessed.heads
    stresses_dict = preprocessed.stresses_dict 
    Nint_dict = preprocessed.Nint_dict
    all_data_for_neural_networks = preprocessed.all_data_for_neural_networks
    all_targets_for_neural_networks = preprocessed.all_targets_for_neural_networks

    


    for key in stresses_dict:
        for e in stresses_dict[key]:
            stresses_dict[key][e].plot()



    parametersLogistic = ParametersLogistic(md,stresses_dict = stresses_dict, heads = heads)
    p_dict = parametersLogistic.assemble_p()

    
       

    simulation = Simulation(time = time, p_dict = p_dict, stresses_dict = stresses_dict, Nint_dict = Nint_dict,
                            time_step = time_step, heads = heads, model_residuals = False)
    sim = simulation.simulate()
    plotax = simulation.plot()
    
    jacobian = Jacobian(simulation).evaluate()
    
    print('456 jacobian',jacobian)
    
    
