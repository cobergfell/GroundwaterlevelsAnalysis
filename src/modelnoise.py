# -*- coding: utf-8 -*-
"""
Created on Wed Mar  8 21:10:14 2023

@author: christophe
"""


import os
import numpy as np
from logging import getLogger
from collections import OrderedDict
from stresstimeseries import Stress
from headstimeseries import Heads
from matplotlib.pyplot import figure, show,savefig,clabel,contour,setp,gcf,getp,gca,close
from preprocessedseries import Preprocessed




logger = getLogger(__name__)

  
    
class NoiseFunctionsParent:

    """
    A parent class that provides instances of simulation of
    the residuals time series, which is the difference between observations and 
    that part of the model taking the observed stresses as input 
    (the so-called deterministic part of the model).
    
    The difference between the observations and the sum of the deterministic 
    model and the residual model is refered to as 'noise' time series.
        
    
    ...
    
    Attributes
    ----------
        
    p_dict : python object of data type 'dict'
        The dictionary defining the model parameters and associated 
        specifications such as associated indexes, names, logtransformed or not, 
        variable or fixed etc. See the the parameterslogistic.py module for additional details.
        
    noise_name : string (optional)
        An optional string to specify the name of the noise function
        

    Methods
    -------
    
    get_initial_parameters()
        Method that returns the initial parameters

    
    """        

    
    def __init__(self,p_dict = None, noise_name = None, suffix = ""):
        
        self.noise_name = noise_name
        self._p_dict = p_dict
        
    
    def get_initial_parameters(self, suffix = ""):

        """
        Method that returns the initial parameters 
        
        Parameters
        ----------
        
        suffix : string (optional)
            An optional string to disambiguate a parameter name (if necessary) 
            

        Returns
        -------
        parameters: python object of data type 'dict'
            A dictionary of initial parameters definitions        
    
        """          
    pass


    def estimate_noise(self):
        
        """
        A function to estimate the noise time series after 
        modeling the residual time series.
        
        Returns
        -------
        noise: numpy array_like
            time-series of noise terms        

        """
        pass 

    def simulate_residuals(self):
        
        """
        A function to model the residuals
        
        Returns
        -------
        residuals: numpy array_like
            time-series of modeled residuals       

        """
        pass 


class ResidualsDecayExponentially(NoiseFunctionsParent):
    
    """
     
     A subclass of NoiseFunctionsParent modelling the residuals as an expnentially
     decaying function of time
    
     Attributes (in complemnt of the attributes of the parent function)
     ----------
    
     time : numpy array_like
     An arrays of time numbers generated by matplotlib.dates function date2num
     when prepocessing the input time series using the preprocessedseries.py module   
    
     heads : Heads object or list of Heads objects
     Single Heads object or list of Heads objects containing the observed groundwater levels,
     associated metadata and preprocessed versions of the groundwater level time series 
     
    deterministic_simulation: Simulation object
    A deterministic simulation, that is, that part of the simulation taking
    observed stresses as input
      
     targets_weighting_method : string
     A string specifying the weighing methode (not implemented yet)  
     
     See Von Asmuth and Bierkens (2005)
    
    
     Notes
     -----
     Calculates the noise as
     noise(t1) = residual(t1) - residual(t0) * exp(-(t2-t1)/alpha,
                                               with alpha the decay 
                                               factor
     
    """
        
        
    def __init__(self, p_dict = None, time = None, heads = None, 
                 deterministic_simulation = None, targets_weighting_method = None, 
                 noise_name = "residuals_decay_exponentially", suffix = ""):
        
        NoiseFunctionsParent.__init__(self,p_dict = p_dict, noise_name = noise_name, suffix = suffix)
        self.heads = heads
        self.time = time
        self.deterministic_simulation = deterministic_simulation
        self.noise_name = noise_name
        self.targets_weighting_method = targets_weighting_method
 

    def get_initial_parameters(self, suffix = ""):
        
        """
        See description of the method in the parent class
        
        """        
        noise_name = self.noise_name
        if suffix != "":
            suffix = '_' + suffix 
            
        parameters = OrderedDict()
        
        if noise_name in  ["residuals_decay_exponentially"]:
            pname = "alpha" + suffix
            parameters[pname] = {
                "isvariable": True,
                "logtransform": True,
                "pname": pname,
                "minvalue": 1e-4,
                "maxvalue": 1000,
                "initvalue": 14, # make noise memory relatively small at begin to limit interference with other parameters
                }  

        return parameters      


        
  

    def estimate_noise(self):  
        
        """
        A function to estimate the noise time series after 
        modeling the residual time series.
        
        Returns
        -------
        noise: numpy array_like
            time-series of noise terms

        """
                 
        p_dict = {}
        for key in self._p_dict:
            p_dict[key] = self._p_dict[key]
            
        time = self.time
        heads = self.heads
        deterministic_simulation = self.deterministic_simulation
        targets_weighting_method = self.targets_weighting_method

        pnames_global = p_dict["pnames"]
        p_global = p_dict['p']
        
        logtransform_global = p_dict["logtransform"]

        indices = p_dict["p_indexes"]['noise']['regime_1']['basicparam']  # we consider only one possible noise regime for now
        pnames = [pnames_global[index] for index in indices]
        p = [p_global[index] for index in indices]
        logtransform = [logtransform_global[index] for index in indices]

        if logtransform[0] == True:
            alpha = np.exp(p[0])
        else: 
            alpha = p[0]
            
            
        targets = heads.targets
        targets_selector = heads.targets_selector

        residuals = targets[:,1]-deterministic_simulation[targets_selector,1]
        


        noise = np.empty((len(targets),2),dtype=float)
        noise[:,0] = targets[:,0]
        noise[0,1] = residuals[0]
        
        delt = targets[1:,0] - targets[0:-1,0]
        residual_expected = np.exp(-delt / alpha) * residuals[:-1]
        noise[1:,1] = residuals[1:] - residual_expected

        
        if targets_weighting_method == "SWSI": # sum of weighted squared innovations (SWSI) see von Asmuth and Bierkens (2005)
        
            try:
                N = len(delt)
                intermediary_serie = np.empty(N,dtype=float)
                intermediary_serie[:] = 1 - np.exp(- 2 * delt / alpha)
                intermediary_serie_product = np.prod(intermediary_serie)
                intermediary_serie_product_Nth_root = np.power(intermediary_serie_product,1./N)
                weights = np.empty(N,dtype=float)
                weights = intermediary_serie_product_Nth_root * intermediary_serie
                weights_sum = sum(weights) 

            except :
                clsname = str(self.__class__.__name__)
                modulename = str(__name__) 
        
                message = (f'\nIn class {clsname} of module {modulename}.py: '
                           'SSWSI could not be evaluated, all weights are set equal to 1.\n ')                      
                logger.warning(message)                    
                
            finally:         
                logger.warning("SSWSI could not be evaluated, all weights are set equal to 1 ")
                weights = np.ones(len(targets),dtype=int)

            heads.weights = weights    
            
            

        return noise
    
    
    
    
    def simulate_residuals(self):  
        
        """
        A function to model the residuals
        
        Returns
        -------
        residuals: numpy array_like
            time-series of modeled residuals       

        """  
        
        p_dict = {}
        for key in self._p_dict:
            p_dict[key] = self._p_dict[key]
        
        
        time = self.time
        heads = self.heads
        deterministic_simulation = self.deterministic_simulation
        targets_weighting_method = self.targets_weighting_method

        pnames_global = p_dict["pnames"]
        p_global = p_dict['p']
        logtransform_global = p_dict["logtransform"]
        indices = p_dict["p_indexes"]['noise']['regime_1']['basicparam']  # we consider only one possible noise regime for now
        pnames = [pnames_global[index] for index in indices]
        p = [p_global[index] for index in indices]
        logtransform = [logtransform_global[index] for index in indices]

        if logtransform[0] == True:
            alpha = np.exp(p[0])
        else: 
            alpha = p[0]
            
            
        targets = heads.targets
        targets_selector = heads.targets_selector

        residuals = np.empty((len(targets),2),dtype=float)
        residuals[:,0] = targets[:,0]
        residuals[:,1] = targets[:,1]-deterministic_simulation[targets_selector,1]
        
        simulated_residuals = np.empty((len(time),2),dtype=float)
        simulated_residuals[:,0] = time[:]
        simulated_residuals[0,1] = residuals[0,1]
        
        
        for i in range(1,len(residuals)):
            time_window_begin = residuals[i-1,0]
            time_window_end = residuals[i,0]
            mask = (time >= time_window_begin) & (time <= time_window_end)
            time_window_delt = time[mask][1:] - time[mask][0:-1]
            simulated_residuals[mask][0,1] = residuals[i,1] 
            simulated_residuals[mask][1:,1] = simulated_residuals[mask][0,1] * np.exp(-time_window_delt / alpha)
              
            
        return simulated_residuals    
    

                                  
if __name__ == "__main__":
    from modelnoise import ResidualsDecayExponentially
    from parameterslogistic import ParametersLogistic
    from modeldefinition import ModelDefinition
    from simulationV3 import Simulation
    from utilities import *
    
    #curdir=os.getcwd()
    abs_path = os.path.dirname(os.path.abspath(__file__))
    abs_path_splitted = abs_path.split('\\')
    path_to_parent_folder_elements = abs_path_splitted[:-1]
    path_to_parent_folder = os.path.join(*path_to_parent_folder_elements)
    splitted = path_to_parent_folder.split(':')#trick  to  repair  path
    path_to_parent_folder = splitted[0]+':\\'+splitted[1]#trick  to  repair  path
    path_to_file_folder = os.path.join(path_to_parent_folder,'resources')  

    stresses_dict = {}
    
    
    # # test Middle Netherlands
    # path_to_file = os.path.join(path_to_file_folder,'260_De_Bilt_PREC_19010101_20200910.csv')
    # key = basename(path_to_file)
    # stresses_dict['prec'] = {}
    # stresses_dict['prec'][key] = Stress.read_from_csv(csv_file = path_to_file, stress_type = 'prec',cumulative = True)    
    

    # path_to_file=os.path.join(path_to_file_folder,'260_De_Bilt_EVAP_19010101_20200910.csv')
    # key = basename(path_to_file)
    # stresses_dict['evap'] = {}
    # stresses_dict['evap'][key] = Stress.read_from_csv(csv_file = path_to_file, stress_type = 'evap',cumulative = True)    
    
    

    # test river Aa Brabant (Netherlands)
    path_to_file = os.path.join(path_to_file_folder,'375_PREC_19510101_20130603.csv')
    key = basename(path_to_file)
    stresses_dict['prec'] = {}
    stresses_dict['prec'][key] = Stress.read_from_csv(csv_file = path_to_file, stress_type = 'prec',cumulative = True)    

    path_to_file=os.path.join(path_to_file_folder,'375_EVAP_19510101_20130603.csv')
    key = basename(path_to_file)
    stresses_dict['evap'] = {}
    stresses_dict['evap'][key] = Stress.read_from_csv(csv_file = path_to_file, stress_type = 'evap',cumulative = True)    
    
    path_to_file=os.path.join(path_to_file_folder,'raai2_251A_20082012_repared.csv')
    key = basename(path_to_file)
    stresses_dict['riv'] = {}
    stresses_dict['riv'][key] = Stress.read_from_csv(csv_file = path_to_file, stress_type = 'riv',cumulative = False)    

    # test pump
    # stresses_dict['pump'] = {}
    # path_to_files_folder = os.path.join(path_to_parent_folder,'resources','selected_wells_paper1_reformatted')  
    # list_of_files_names = os.listdir(path_to_files_folder)
    # for filename in list_of_files_names:
    #     path_to_file = os.path.join(path_to_files_folder,filename)
    #     key = basename(path_to_file)
    #     stresses_dict['pump'][key] = Stress.read_from_csv(path_to_file, stress_type = 'pump',cumulative = False)    

    tminstr = '01-01-1900 08:00:00'
    tmaxstr = '31-12-2100 08:30:00'
    
    path_to_file_folder = os.path.join(path_to_parent_folder,'resources')  
    path_to_file = os.path.join(path_to_file_folder,'28AP0093_1.txt')
    heads = Heads.read_from_csv(path_to_file, tminstr = tminstr, tmaxstr = tmaxstr)
    
    
    path_to_file_folder = os.path.join(path_to_parent_folder,'resources')  
    path_to_file = os.path.join(path_to_file_folder,'P8.txt')
    heads = Heads.read_from_csv(path_to_file, tminstr = tminstr, tmaxstr = tmaxstr)    
    heads.L = 1 #layer number (index top layer is 0)



    for key in stresses_dict:
        for e in stresses_dict[key]:
            stresses_dict[key][e].plot()

    md = ModelDefinition().model_definition
    memory_dict = ModelDefinition().memory_dict
    parametersLogistic = ParametersLogistic(md)
    
    memory_dict = {'prec':365*5,
          'evap':365*5,
          'riv':7,
          'pump':365*5,
          'noise':30}     
    
    
    memory_dict = {'prec':1000,
          'evap':1000,
          'riv':1000,
          'pump':365,
          'noise':30}         
    
    
    time_step = 1. #1./(24.*2)

    preprocessed = Preprocessed(heads = heads,stresses_dict = stresses_dict, time_step = time_step, 
                                memory_dict = memory_dict,tminstr = tminstr, tmaxstr = tmaxstr,
                                model_definition = md).preprocess()
    time = preprocessed.time
    heads = preprocessed.heads
    stresses_dict = preprocessed.stresses_dict 
    Nint_dict = preprocessed.Nint_dict
    all_data_for_neural_networks = preprocessed.all_data_for_neural_networks
    all_targets_for_neural_networks = preprocessed.all_targets_for_neural_networks

    
    parametersLogistic = ParametersLogistic(md,stresses_dict = stresses_dict, heads = heads)
    p_dict = parametersLogistic.assemble_p()



    simulation = Simulation(time = time, p_dict = p_dict, stresses_dict = stresses_dict, Nint_dict = Nint_dict,
                            time_step = time_step, heads = heads, model_residuals = False)
    sim = simulation.simulate()
    plotax = simulation.plot()
 

    resmodel = ResidualsDecayExponentially(p_dict = p_dict, time = time, heads = heads, 
                                        deterministic_simulation = sim, targets_weighting_method = None)
    
    noise = resmodel.estimate_noise()
    res = resmodel.simulate_residuals()


    # potimizer = Poptimizer(time, p_dict, heads = heads, stress_dict = stresses)
    # #popt, pcov, pcor, stderr, p_dict = potimizer.scipy_optimize_leastsq()
    # popt, pcov, pcor, stderr, p_dict = potimizer.scipy_optimize_least_squares()
    
    # simulation = Simulation(time, p_dict, stresses)    
    # sim = simulation.simulate()
    # obs = heads.observed
    
    
    # #plot to check in development phase
    # from matplotlib.pyplot import figure, show,savefig,clabel,contour,setp,gcf,getp,gca
    # from matplotlib.dates import DayLocator,MonthLocator,YearLocator,DateFormatter #HourLocator,Yearlocator
    # fig=figure()
    # ax = fig.add_subplot(111)
    # ax.set_title('This is just a check during development ')
    # ax.plot_date(obs[:,0],obs[:,1],'b')
    # ax.plot_date(sim[:,0],sim[:,1],'r')
    # leg = ax.legend((["observed","simulated",]),loc='upper left',shadow=False)
    # ax.set_xlabel('time')
    # ax.grid(False)
    # ax.fmt_xdata = DateFormatter('%Y-%m-%d')                        # %H:%M:%S
    # fig.autofmt_xdate()
    # show()
