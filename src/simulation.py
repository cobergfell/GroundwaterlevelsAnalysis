# -*- coding: utf-8 -*-
"""
Created on Fri Feb  3 21:02:57 2023

@author: christophe

"""

# from scipy import interpolate
import os
import numpy as np
from datetime import datetime
from matplotlib.dates import date2num, num2date
from matplotlib import pyplot as plt
from logging import getLogger
from stresstimeseries import Stress
from headstimeseries import Heads
from preprocessedseries import Preprocessed
from stressconvolution import StressConvolution
from parameterslogistic import ParametersLogistic
from modeldefinition import ModelDefinition
from modelnoise import ResidualsDecayExponentially
from utilities import datestring2num, basename, generate_ticks
from plotfunctions import simpleplot
from rootzone import Vangenuchten
from modeldefinition import ModelDefinition
from harmonics_toolkit import *


logger = getLogger(__name__)


class Simulation:
    
    """
        A class that provides instances of groundwater head time series simulations
    
        ...
    
    Attributes
    ----------
        
    _time : numpy array_like
        A local copy of time, an arrays of time numbers generated by matplotlib.dates function date2num
        when prepocessing the input time series using the preprocessedseries.py module
        
        
    _p_dict : python object of data type 'dict'
        _p_dict is a local copy of the p_dict dictionary defining the model parameters
        and associated specifications such as associated indexes, names, logtransformed or not, 
        variable or fixed etc. See the the parameterslogistic.py module for additional details.
        
    _stresses_dict : python object of data type 'dict'
        _stresses_dict is a local copy of the stresses_dict dictionary containing all the entered
        Stress objects used to explain the observed groundwater levels variations.
        
    heads : Heads object or list of Heads objects
        Single Heads object or list of Heads objects containing the observed groundwater levels,
        associated metadata and preprocessed versions of the groundwater level time series 

    settings : python object of data type 'dict' (optional)
        An optional dictionnary of settings - not used in present version

    Nint_dict : python object of data type 'dict'
        A dictionary specifying per stress the memory of each stress, expressed 
        in number of time intervals (a time interval equals a time step)
        
    time_step : float
        The specified time step used for all heads and stresses time series     
          
    arguments_dict : python object of data type 'dict'
        A dictionary specifying additional arguments to pass to the response functions.
        For example: X,Y coordinates of pumping wells          
        
    time_boundaries_sim : python object of data type 'dict'
        A dictionary specifying the time boundaries of the simulation          
        
    targets_weighting_method : string
        A string specifying the weighing methode (not implemented yet)     
        
    model_definition : Modeldefinition object
        A Modeldefinition object specifying how the time series analysis is implemented 
        (which is the first step in the present time series analysis methodology) 
           
    _components : python object of data type 'dict'
        A dictionary containing the seperate components of the time series model         



    
    Methods
    -------
    
    simulate()
        Simulate the groundwater levels time series given the variables entered in the
        definition of the class object
        
        
    
    plot(tminstr = '01-01-1900', tmaxstr = '31-12-2100', Yticks = None)    
        Plot the simulation
        

    """    
    
    
    
    

               
    def __init__(self, time = None, p_dict = None, stresses_dict = None, 
                 heads = None,time_step = None, Nint_dict = None, tminstr = None, 
                 tmaxstr = None, tminnum = None, tmaxnum = None, settings = None, 
                 targets_weighting_method = None, model_residuals = False, 
                 model_definition = None):

        #local copy of mutable input dictionaries
        _p_dict = {}
        for key in p_dict:
            _p_dict[key] = p_dict[key]

        _stresses_dict = {}
        for key in stresses_dict:
            _stresses_dict[key] = stresses_dict[key]
    
        self._p_dict =  _p_dict
        self._stresses_dict =  _stresses_dict
        self._time = time
        self._heads = heads
        self.settings = settings
        self.Nint_dict = Nint_dict
        if time_step is None:
            time_step = 1.0
        self.time_step = time_step
        self.targets_weighting_method = targets_weighting_method
        self.model_residuals = model_residuals
        self._components = None
        if model_definition is None:
            model_definition = ModelDefinition().model_definition
        self.model_definition = model_definition

        if 'prec' in self.model_definition['constrain_with_harmonics']:
            self._p_dict = update_P_given_harmonic_components(self._p_dict, self._stresses_dict, self._heads)
            
                          
        t = lambda t_str : date2num(datetime.strptime(t_str,'%d-%m-%Y')) 

        tmin = None
        tmax = None
        
        if time is not None:
            tmin = time[0]
            tmax = time[-1]
        
        if tminnum is not None and tminstr is not None:
            logger.warning("Minimum time is both given as string and numeric value."
                              "String value will be ignored")
            
        if tmin is None and tminnum is None and tminstr is None:
            tmin = t('01-01-1900')

   
        if tminstr is not None:
            tmin = datestring2num(tminstr)
            
        if tminnum is not None:   
             tmin = tminnum
                         
             
        if tmaxnum is not None and tmaxstr is not None:
            logger.warning("Maximum time is both given as string and numeric value."
                              "String value will be ignored")
            
        if tmax is None and tmaxnum is None and tmaxstr is None:
            tmax = t('31-12-2100')
                        
        if tmaxstr is not None:
            tmax = datestring2num(tmaxstr)
         
        if tmaxnum is not None:   
             tmax = tmaxnum                  
            
        
        self.tmin = tmin
        self.tmax = tmax
        self._simulated = self.simulate()        


               
    def __repr__(self):
        """String representation of the simulation."""

        string = 'Convolution of:\n'
        for stress in self._stresses_dict:
            string += f'{repr(self._stresses_dict[stress])}.\n'

        return string
                
            
        
    @property
    def simulated(self):
        """getter for updated simulated time series."""
        return self._simulated

    @simulated.setter
    def simulated(self,simulated):
        """setter for updated simulated time series."""
        self._simulated = simulated  
        
        
    @property
    def p_dict(self):
        """getter for updated p_dict."""
        return self._p_dict

    @p_dict.setter
    def p_dict(self,simulated):
        """setter for updated p_dict."""
        self._p_dict = p_dict          
        
    @property
    def stresses_dict(self):
        """getter for updated stresses_dict."""
        return self._stresses_dict

    @stresses_dict.setter
    def stresses_dict(self,stresses_dict):
        """setter for updated stresses_dict."""
        self._stresses_dict = stresses_dict         

    @property
    def heads(self):
        """getter for updated heads."""
        return self._heads

    @heads.setter
    def heads(self,heads):
        """setter for updated heads."""
        self._heads = heads            
        
        
    @property
    def time(self):
        """getter for updated time."""
        return self._time

    @time.setter
    def time(self,time):
        """setter for updated time."""
        self._time = time            
        
    @property
    def components(self):
        """getter for components dict."""
        return self._components

    @components.setter
    def components(self,components):
        """setter for updated components."""
        self._components = components            
        
 
    def simulate(self):

        """
        Method that returns the simulation of groundwater heads given a parameters vector
        
        ----------
        Parameters
        ----------
        The parameters needed are entered by initializing the class object, see Class documentation           
                
    
        Returns
        -------
        simulation: numpy array_like
                array of simulated time series
        
        """
      
        p_dict = {}
        for key in self._p_dict:
            p_dict[key] = self._p_dict[key]
             
        stresses_dict = {}
        for key in self._stresses_dict:
            stresses_dict[key] = self._stresses_dict[key]
        
        time = self._time
        heads = self._heads
        X  = heads.X
        Y = heads.Y
        Z = heads.Z
        L = heads.L
        tmin = self.tmin
        tmax = self.tmax
        time_step = self.time_step
        model_residuals = self.model_residuals
        Nint_dict = self.Nint_dict
        settings = self.settings
        model_definition = self.model_definition
        components = {}

        try:
            simulation = np.zeros((len(time),2))
            simulation[:,0] = time
        except:
            
            clsname = str(self.__class__.__name__)
            modulename = str(__name__)
            message = (f'\nIn class {clsname} of module {modulename}.py: No valid time array was entered,'
                       f'check time overlap of all time series.\n')                 
            
            logger.error(message)            
            

        p_indexes = p_dict['p_indexes']
        logtransform = p_dict['logtransform']

        
        for stress_type in stresses_dict:
            
            components[stress_type] = {}

            Nint = Nint_dict[stress_type]
            if stress_type in ['evap','pump']:
                sign = -1
            else:
                sign = 1


            arguments_dict = {}
            
            toconvolve = True     
            for e in stresses_dict[stress_type]:
                
                if stress_type not in p_dict['componentsnames']:
                    toconvolve = False
 
                if toconvolve == True:

                    if stress_type == 'pump':
                        arguments_dict['Xwell'] = stresses_dict[stress_type][e].X
                        arguments_dict['Ywell'] = stresses_dict[stress_type][e].Y
                        arguments_dict['Xpiezo'] = X 
                        arguments_dict['Ypiezo'] = Y 
                        arguments_dict['Zpiezo'] = Z
                        arguments_dict['Lpiezo'] = L              
                        
                    if model_definition[stress_type]['funct_type'] in ['floodwavemodel2L_typeI']:
                        
                        if 'riv' in stresses_dict:

                            river_series_name = list(stresses_dict['riv'].keys())[0]#there is only one list element
                            Xriv = stresses_dict['riv'][river_series_name].X
                            Yriv = stresses_dict['riv'][river_series_name].Y                        
    
                            try:
                                river_series_name = list(stresses_dict['riv'].keys())[0]#there is only one list element
                                Xriv = stresses_dict['riv'][river_series_name].X
                                Yriv = stresses_dict['riv'][river_series_name].Y
        
                                arguments_dict['Xriv'] = Xriv
                                arguments_dict['Yriv'] = Yriv
                                arguments_dict['Xpiezo'] = X 
                                arguments_dict['Ypiezo'] = Y      
                                arguments_dict['Zpiezo'] = Z
                                arguments_dict['Lpiezo'] = L                            
                                
                            except:
                                clsname = str(self.__class__.__name__)
                                modulename = str(__name__)
                                message = (f'\nIn class {clsname} of module {modulename}.py: FloodWaveModel2L'
                                            f'Xriv and Yriv are required imputs when using FloodWaveModel2L as response'
                                            f'for "prec", "evap" or "riv".\n')     
                                            
                                logger.error(message)                          
    
                    if model_definition[stress_type]['use_normalized_time_series'] == True:
                        preprocessed_stress = stresses_dict[stress_type][e].interpolated_normalized   
                    else:
                        preprocessed_stress = stresses_dict[stress_type][e].interpolated
                    
                    if stress_type == 'prec':
                        if self.model_definition['root_zone']['apply_root_zone'] == True:
                            if self.model_definition['root_zone']['funct_type'] == 'vangenuchten':
                                rootzone_instance = Vangenuchten(p_dict = p_dict, stresses_dict = stresses_dict, time_step = 1.0, 
                                  root_zone_model = 'Brooks_and_Corey')
                            else: # make vangenuchten the default root zone model
                                rootzone_instance = Vangenuchten(p_dict = p_dict, stresses_dict = stresses_dict, time_step = 1.0, 
                                  root_zone_model = 'Brooks_and_Corey')
                            
                            preprocessed_stress = rootzone_instance.estimate_percolation()

                    sc = StressConvolution(preprocessed_stress = preprocessed_stress, stress_type = stress_type, 
                                           p_dict = p_dict, time = time, Nint = Nint, time_step = time_step, 
                                           tminnum = tmin, tmaxnum = tmax, arguments_dict = arguments_dict)
                    convolved_stress = sc.convolve_stress() 
                    convolved_stress[:,1] = sign * convolved_stress[:,1]
                    mask = np.isnan(convolved_stress[:,1])
                    convolved_stress[mask,1] = 0

                    simulation[:,1] = simulation[:,1] + convolved_stress[:,1]

                    components[stress_type][e] = convolved_stress
      
        
        if model_definition['db']['mean_observed_heads_minus_mean_response'] == False:
            components['constant base'] = {}
            components['constant base']['db'] = {}
            i = p_indexes['db']['regime_1']['basicparam'][0]
            db = p_dict['p'][i]
            
            if p_dict['logtransform'][i] == True:
                db = np.exp(db)
                   
            db_as_component = np.empty(np.shape(simulation))
            db_as_component[:,0] = simulation[:,0]
            db_as_component[:,1] = db
            components['constant base']['db'] = db_as_component
          
            
        else:
            mean_response = np.mean(simulation[:,1])    
            mean_heads_obs = np.mean(heads.interpolated[:,1])
            db = mean_heads_obs - mean_response
 
            components['constant base'] = {}
            components['constant base']['db'] = {}
            i = p_indexes['db']['regime_1']['basicparam'][0]
            p_dict['p'][i] = db

            db_as_component = np.empty(np.shape(simulation))
            db_as_component[:,0] = simulation[:,0]
            db_as_component[:,1] = db
            components['constant base']['db'] = db_as_component          

        simulation[:,1] = simulation[:,1] + db
        
        self._simulated = simulation
        
        self.components = components
        
       
        if model_residuals == True:
            if p_indexes['noise'] is not None:
                if heads is not None:
                    noisefunctclassname = p_dict['componentsnames']['noise']
                    simulated_residuals = eval( noisefunctclassname + "(p_dict = p_dict, time = time, heads = heads, deterministic_simulation = simulation).simulate_residuals()")
                    # simulated_residuals = noisefunctclassname(p_dict = p_dict, time = time, heads = heads, deterministic_simulation = simulation, weighting_method = targets_weighting_method).model_residuals()
                    # simulated_residuals = ResidualsDecayExponentially(p_dict = p_dict, time = time, heads = heads, deterministic_simulation = sim, weighting_method = "SWSI").model_residuals()
                    simulation = simulation + simulated_residuals
                    #self.components["simulated residuals"] = simulated_residuals

                else:
                    logger.warning("Heads must be provided to model noise")
                    
                
                
        return simulation
    
    

    
    
    
    def plot(self, tminstr = '01-01-1900', tmaxstr = '31-12-2100', Yticks = None):
        
        """
        A Method to plot the time series model
        
        Parameters
        ----------    

        tminstr: string (optional)
                string specifying the minimum time on the plot (format dd-mm-yyyy)
                
        tmaxstr: string (optional)
                string specifying the maximum time on the plot (format dd-mm-yyyy)     
                
        Yticks: numpy array_like (optional)
                Y axis tick labels                   
    
        Returns
        -------
        ax: Matplotlib Axes object
                The Matplotlib Axes object
        
        """        
        from matplotlib.pyplot import figure, show,savefig,clabel,contour,setp,gcf,getp,gca,close
        from matplotlib.dates import DayLocator,MonthLocator,YearLocator,DateFormatter #HourLocator,Yearlocator
        from datetime import datetime
        from matplotlib.dates import date2num, num2date, DayLocator,YearLocator,DateFormatter #HourLocator,Yearlocator
        from matplotlib.ticker import Formatter,FuncFormatter, NullLocator, FixedLocator
        from matplotlib import rcParams
        rcParams['text.usetex'] = False#True
        
        fs = 12
 
        time = self._time
        tmin = self.tmin
        tmax = self.tmax
        simulation = self._simulated
        interpolated = self._heads.interpolated
       
        t = lambda t_str : date2num(datetime.strptime(t_str,'%d-%m-%Y'))
        tmin = max(t(tminstr),simulation[0,0])  
        tmax = min(t(tmaxstr),simulation[-1,0])  
 
        left_margin=0.12
        right_margin=0.06
        top_margin=0.05
        bottom_margin=0.14
        dy=0.05
        dx=0.05
    
        nl = 1 #number of rows
        nc = 1 #number of columns
        plot_length = (1-left_margin-right_margin-dx)/nc
        plot_height = (1-bottom_margin-top_margin-2*dy)/nl
        x1 = left_margin
        x2 = x1+plot_length+dx # in case of double columns 
        X = [x1,x2,x1,x2,x1,x2,x1,x2]#list of x coordinates of bottom left corners
        y1 = 1-top_margin-plot_height
        y2 = y1-plot_height-dy # in case of 2 rows
        y3 = y2-plot_height-dy # in case of 3 rows
        y4 = y3-plot_height-dy # in case of 4 rows
        Y = [y1,y1,y2,y2,y3,y3,y4,y4]#list of x coordinates of bottom left corners    
        
        
        fig=figure(num=None, figsize=(10,10),dpi=50,facecolor='w', edgecolor='k')#figures with all plots in a colomn
        #ax = fig.add_subplot(111)
        ax=fig.add_axes([X[0],Y[0],plot_length,plot_height],frameon=True, xscale=None, yscale=None)    #where rect=[left, bottom, width, height] in normalized (0,1) units. axisbg is the background color for the axis, default white
        legend_list = []
        vmin = 1e9
        vmax = -1e9
        mask = (simulation[:,0] >= tmin) & (simulation[:,0] < tmax)
        simulation = simulation[mask]
        vmin = min(vmin,min(simulation[:,1]))
        vmax = max(vmax,max(simulation[:,1]))
        observation = self._heads.observed
        mask = (observation[:,0] >= tmin) & (observation[:,0] < tmax)
        observation = observation[mask]        
        vmin = min(vmin,min(observation[:,1]))
        vmax = max(vmax,max(observation[:,1]))

        ax.plot_date(observation[:,0],observation[:,1],'b')
        legend_list.append('observed')
        ax.plot_date(simulation[:,0],simulation[:,1],'r')  
        legend_list.append('simulated')
        ax.plot_date(interpolated[:,0],interpolated[:,1],'g')
        legend_list.append('interpolated')  
        

        colors = ['m','y','c','g', 'tab:green','tab:olive', 'tab:purple','tab:pink','tab:orange','tab:brown' ]
        keys1 = list(self.components)
        for i in range(0, len(keys1)):
            key1 = keys1[i]
            keys2 = list(self.components[key1])
            
            for j in range(0, len(keys2)):
                key2 = keys2[j]
                component = self.components[key1][key2]
                mask = (component[:,0] >= tmin) & (component[:,0] < tmax)
                component = component[mask]  

                try:
                    vmin = min(vmin,min(component[:,1]))
                    vmax = max(vmax,max(component[:,1]))
                except:
                    pass
                ax.plot_date(component[:,0],component[:,1],colors[i])    
                text = key1+'_'+key2
                legend_list.append(text)
        
        
        # def magnitude(x):
        #     import math
        #     return int(math.floor(math.log10(x)))


        
        # def orderOfMagnitude(number):
        #     import math
        #     return math.floor(math.log(number, 10))


        
        
        # def generate_ticks(vmin,vmax):
        #     import math
        #     valuesrange = vmax - vmin
        #     valuesrangemagnitude = orderOfMagnitude(valuesrange)
        #     #scaledvaluesrange = valuesrange/np.power(10,valuesrangemagnitude)
       
            
        #     magnitudevmin = orderOfMagnitude(vmin)
        #     tickmin = math.floor(float(vmin)/np.power(float(10),magnitudevmin) ) * np.power(float(10),magnitudevmin)
            
        #     if valuesrangemagnitude >= 1:
        #         exponent = valuesrangemagnitude-1
        #         increment = 0.5 * np.power(float(10),exponent)
        #     else:
        #         increment = 0.5
                
           
        #     magnitudevmax = orderOfMagnitude(vmax)
        #     vmax = vmax + 2 *  increment      

        #     ticks = np.arange(tickmin,vmax,increment)
            
        #     # if scaledvaluesrange <=5 :
        #     #     ticks = np.arange(tickmin,tickmin + 5 * np.power(10,valuesrangemagnitude),0.5* np.power(10,valuesrangemagnitude))
        #     # else :
        #     #     ticks = np.arange(tickmin,tickmin + 10* np.power(10,valuesrangemagnitude),np.power(10,valuesrangemagnitude))
        #     print('333 ticks',ticks)
            
        #     return ticks
        
        
        def format_pump_rate(x):
            return '%1.0f' % (x*1e-3)
    
        def format_date(dates, pos=None):
            return num2date(dates).strftime('%d-%m-%Y')
        
        # def format_date(dates, pos=None):
        #     return num2date(dates).strftime('%Y')
        
        # def format_date(dates, pos=None):
        #     return num2date(dates).strftime('%d-%m-%Y %H:%M')        

    
        ticks = generate_ticks(vmin,vmax)
        ax.set_ylim(ticks[0],ticks[-1])
        
    
        majorLocator   = FixedLocator(ticks) 
        ax.yaxis.set_major_locator(majorLocator)
        ax.set_ylabel('head (m above datum)',fontsize=fs)
  
        # ax.set_xlabel('date (dd-mm-yyyy)',fontsize=fs, rotation=20)
        ax.set_xlabel('date (yyyy)',fontsize=fs)
        ax.xaxis.set_major_formatter(FuncFormatter(format_date))
        #fig.autofmt_xdate()
        #ax.xaxis.set_label_position('right')
        
        for tick in ax.xaxis.get_major_ticks():
            tick.label.set_fontsize(fs)
            tick.label.set_rotation(45)
        
        for label in ax.xaxis.get_majorticklabels():
            #ha=label.get_horizontalalignment()
            label.set_horizontalalignment('center')
                
        # title_name=m.split('_')[0]
        # title_name='Piezometer '+piezo_number+list_of_NS[i]
        # ax.set_title(title_name, fontsize=fs)
        
        


        ax.set_title('Simulation components',fontsize=fs)
        
        
        (x, y) = ax.title.get_position()
        ax.title.set_y(0.87 * y)    

        ax.grid(True)
        
        # ax.fmt_xdata = DateFormatter('%Y-%m-%d')                        # %H:%M:%S
        # fig.autofmt_xdate()
        
                        

 
        ax.annotate('Legend', xy=(0.05, -0.15), xycoords='axes fraction',horizontalalignment='left', verticalalignment='center',fontsize=fs)
        leg = ax.legend((legend_list), ncol=3,shadow=False,bbox_to_anchor=[0.045, -0.3], loc='lower left',frameon=False)
        ltext  = leg.get_texts() 
        plt.setp(ltext, fontsize=fs)    # the legend text fontsize
        # ax.annotate(repr(self), xy=(0.05, -0.22), xycoords='axes fraction',horizontalalignment='left', 
        #             verticalalignment='center',fontsize=fs)
        
        show()
        curdir=os.getcwd()
        #savefig(curdir+'\\simulations', dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None,transparent=False, bbox_inches=None, pad_inches=0.1)


        return ax    
    
    
    
    
if __name__ == "__main__":

    import os
    import numpy as np
    from scipy.optimize import least_squares, leastsq
    from datetime import datetime
    from matplotlib.dates import date2num, num2date
    from logging import getLogger
    
    
    
    #curdir=os.getcwd()
    abs_path = os.path.dirname(os.path.abspath(__file__))
    abs_path_splitted = abs_path.split('\\')
    path_to_parent_folder_elements = abs_path_splitted[:-1]
    path_to_parent_folder = os.path.join(*path_to_parent_folder_elements)
    splitted = path_to_parent_folder.split(':')#trick  to  repair  path
    path_to_parent_folder = splitted[0]+':\\'+splitted[1]#trick  to  repair  path
    path_to_resources_folder = os.path.join(path_to_parent_folder,'resources') 
    path_to_src_folder = os.path.join(path_to_parent_folder,'src') 
    # path_to_src_folder = 'D:\\dev\\_my_own_program\\src'
    
                              
    from stresstimeseries import Stress                                  
    from headstimeseries import Heads
    from parameterslogistic import ParametersLogistic
    from modeldefinition import ModelDefinition
    from modelnoise import ResidualsDecayExponentially
    from utilities import p_dict_copy
    from harmonics import Harmonics
    from harmonics_toolkit import *
    from matplotlib.pyplot import figure, show,savefig,clabel,contour,setp,gcf,getp,gca,close
    from preprocessedseries import Preprocessed
    from jacobian import Jacobian
    from simulation import Simulation                      
    from poptimizer_test import Poptimizer                               
    
    
    
    stresses_dict = {}
    
    # path_to_file = os.path.join(path_to_resources_folder,'260_De_Bilt_PREC_19010101_20200910.csv')
    path_to_file = os.path.join(path_to_resources_folder,'reformated_prec_giersbergen.csv')
    
    key = basename(path_to_file)
    stresses_dict['prec'] = {}
    stresses_dict['prec'][key] = Stress.read_from_csv(path_to_file, stress_type = 'prec',cumulative = True)    
    
    
    path_to_file=os.path.join(path_to_resources_folder,'260_De_Bilt_EVAP_19010101_20200910.csv')
    # path_to_file=os.path.join(path_to_file_folder,'evap_eindhoven.csv')
    
    key = basename(path_to_file)
    stresses_dict['evap'] = {}
    stresses_dict['evap'][key] = Stress.read_from_csv(path_to_file, stress_type = 'evap',cumulative = True)    
    
    
        
    stresses_dict['pump'] = {}
    path_to_files_folder = os.path.join(path_to_resources_folder,'selected_wells_paper1_reformatted')  
    list_of_files_names = os.listdir(path_to_files_folder)
    for filename in list_of_files_names:
        path_to_file = os.path.join(path_to_files_folder,filename)
        key = basename(path_to_file)
        stresses_dict['pump'][key] = Stress.read_from_csv(path_to_file, stress_type = 'pump',cumulative = False)    
    
    
    tminstr = '01-01-1900 08:00:00'
    tmaxstr = '31-12-2100 08:30:00'
    
    
    path_to_piezometers_directory = os.path.join(path_to_resources_folder,'piezometers_paper1') 
    
    heads_list = []
    list_of_piezometers_files_names = os.listdir(path_to_piezometers_directory)
    for filename in list_of_piezometers_files_names: 
        path_to_file = os.path.join(path_to_piezometers_directory,filename)
        heads = Heads.read_from_csv(path_to_file, tminstr = tminstr, tmaxstr = tmaxstr) 
        
        heads_list.append(heads)
        #heads.plot()
    
    
    for key in stresses_dict:
        for e in stresses_dict[key]:
            stresses_dict[key][e].plot()
    
    # md = ModelDefinition().model_definition
    # memory_dict = ModelDefinition().memory_dict
    # parametersLogistic = ParametersLogistic(md)
    
    
    memory_dict = {'prec':600,
          'evap':600,
          'riv':10,
          'pump':10,
          'noise':50}         
    
    
    time_step = 1.#1./(24.*2)
    time_step_targets = 1.5
    
    

    
    if isinstance(heads,list):
        _heads = heads[0]
    else:
        _heads = heads
        
        
    # read model definition
    #curdir=os.getcwd()
    abs_path = os.path.dirname(os.path.abspath(__file__))
    abs_path_splitted = abs_path.split('\\')
    working_directory_elements = abs_path_splitted[:-1]
    working_directory = os.path.join(*working_directory_elements)
    splitted = working_directory.split(':') # trick to repair path
    working_directory = splitted[0]+':\\'+splitted[1] # trick to repair path
    
    # curdir = os.getcwd()
    
    mydir = os.path.join(path_to_parent_folder,'example_1')         
    if not os.path.isdir(mydir):
        os.mkdir(mydir)  
        
    filepath = os.path.join(mydir,'model_definition.json')
    
    md = ModelDefinition().from_jason(filepath=filepath) # case 3: model definition specified in json json file in filepath
    
    
    parametersLogistic = ParametersLogistic(md,stresses_dict = stresses_dict, heads = _heads)
    p_dict = parametersLogistic.assemble_p()
    
    
    preprocessed = Preprocessed(heads = heads_list,stresses_dict = stresses_dict, time_step = time_step,
                                time_step_targets = time_step_targets, memory_dict = memory_dict,tminstr = tminstr, 
                                tmaxstr = tmaxstr, model_definition = md).preprocess() 
        
    time = preprocessed.time
    heads = preprocessed.heads
    
    stresses_dict = preprocessed.stresses_dict 
    Nint_dict = preprocessed.Nint_dict
    all_data_for_neural_networks = preprocessed.all_data_for_neural_networks
    all_targets_for_neural_networks = preprocessed.all_targets_for_neural_networks     
    
    
    _heads = heads_list[0]

    simulation = Simulation(time = time, p_dict = p_dict, stresses_dict = stresses_dict, 
    heads = _heads, time_step = time_step, Nint_dict = Nint_dict, 
    model_residuals = False, model_definition = md)
    
    sim = simulation.simulate()
    
    
    plotax = simulation.plot()
    
    
    
    

    
    
